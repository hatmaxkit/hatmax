# Authentication & Authorization Service Architecture

**Status:** Draft | **Updated:** 2025-10-14 | **Version:** 0.1

## Overview

This document defines the architecture for an optional authentication and authorization service that can be generated by HatMax. The system implements a comprehensive AuthN/AuthZ solution using Go, MongoDB, and HTMX, designed for modern microservice architectures with strong security and privacy requirements.

## 1. System Context

The authentication and authorization system consists of two decoupled microservices:

- **Authentication Service (AuthN)**: Manages identity, credentials, and user sessions
- **Authorization Service (AuthZ)**: Controls access permissions, roles, and scopes

Both services operate on MongoDB using **repository-per-aggregate** patterns, fully decoupled from concrete persistence implementations. The frontend uses **HTML + HTMX** (no SPA) with traditional sessions (`HttpOnly` cookies) and internal fan-out to private APIs within the same network.

## 2. Authentication Service

### 2.1 Core Responsibilities

- User registration (`signup`)
- Login/logout with session management
- Administrative user creation
- Event synchronization to AuthZ service (`UserCreated`, `UserDeactivated`)
- Secure credential storage and validation

### 2.2 Data Model

The User aggregate implements comprehensive security measures:

```go
type User struct {
    ID           uuid.UUID
    EmailCT      []byte    // AES-GCM encrypted email
    EmailIV      []byte    // Initialization vector
    EmailTag     []byte    // Authentication tag
    EmailLookup  []byte    // HMAC-SHA256 for searchability
    PasswordHash []byte    // Argon2id hash
    PasswordSalt []byte    // Random salt
    MFASecretCT  []byte    // Encrypted MFA secret (optional)
    CreatedAt    time.Time
    Status       string    // active, suspended, deleted
}
```

### 2.3 Security & Privacy Policy

#### Encryption and Hashing Strategy

| Data Type | Technique | Rationale |
|-----------|-----------|-----------|
| Passwords | Argon2id hash + salt + pepper (KMS) | Non-reversible by design |
| Email addresses | AES-GCM + HMAC lookup | Required for notifications while protecting PII |
| MFA secrets, recovery codes | Encryption or hash (based on read requirements) | Maximum security |
| Application logs | PII-free or masked | Compliance requirements |
| Database backups | Full encryption | Data protection |

#### MongoDB Schema

```json
{
  "_id": "<uuid>",
  "email_ct": "<base64-encrypted-email>",
  "email_iv": "<base64-iv>",
  "email_tag": "<base64-auth-tag>",
  "email_lookup": "<hex-hmac-hash>",
  "pass_hash": "<base64-argon2id-hash>",
  "pass_salt": "<base64-salt>",
  "created_at": "<iso8601-timestamp>",
  "status": "active"
}
```

#### Authentication Flow

1. **Normalize** email input
2. **Calculate** `lookup = HMAC(email, k_lookup)` for database search
3. **Query** by `email_lookup` field
4. **Verify** password against stored hash
5. **Decrypt** email only when necessary (e.g., for notifications)

#### Newsletter and Consent Management

Separate collection `email_subscriptions` handles marketing consent:

```json
{
  "user_id": "<uuid-optional>",
  "email_ct": "<encrypted-email>",
  "email_lookup": "<lookup-hash>",
  "consent": {
    "type": "marketing",
    "scope": "global",
    "timestamp": "<iso8601>",
    "source_ip": "<client-ip>"
  },
  "confirmed_at": "<timestamp>"
}
```

## 3. Authorization Service

### 3.1 Core Responsibilities

- **Role** management and assignment
- **Permission** definition and evaluation
- **Grant** administration (role and permission assignments)
- Support for both global and contextual permissions
- Policy evaluation engine (`Has(user, permission, scope)`)

### 3.2 Domain Aggregates

#### Role Aggregate
```go
type Role struct {
    ID          uuid.UUID
    Name        string
    Permissions []string  // Permission codes
}
```

#### Grant Aggregate
```go
type Grant struct {
    ID         uuid.UUID
    UserID     uuid.UUID
    GrantType  string     // "role" or "permission"
    Value      string     // RoleID or PermissionCode
    Scope      Scope      // Context scope
    ExpiresAt  *time.Time // Optional expiration
}
```

#### Scope Model
```go
type Scope struct {
    Type string // "global", "team", "organization"
    ID   string // Specific ID or empty for global
}
```

### 3.3 Permission Evaluation

#### Core Evaluation Function
```go
func (p *PDP) Has(userID, permission string, scope Scope) (bool, error)
```

#### Evaluation Algorithm
1. **Retrieve** all grants for `user_id`
2. **Filter** expired grants (`expires_at < now`)
3. **Accept** grants with global scope or matching requested scope
4. **Expand** permissions from assigned roles
5. **Return** `true` if requested permission is found

### 3.4 MongoDB Persistence

#### Collections
- `roles` - Role definitions
- `grants` - User permission assignments

#### Indexes
- `grants.user_id` - Primary lookup
- `grants.scope.type` - Scope filtering
- `grants.scope.id` - Context filtering
- `grants.expires_at` (TTL) - Automatic cleanup

### 3.5 Internal Token Management

- **Internal tokens** use `Bearer` format with Ed25519/PASETO signing
- **Minimal claims**: `sub`, `sid`, `aud`, `ctx`, `exp`, `authz_ver`
- **Cache strategy**: By session+audience (1-5 minute TTL)
- **Revocation**: Session ID denylist or `authz_ver` increment

## 4. Authorization Policies & Resources

### 4.1 Resource Abstraction

A **resource** represents a logical protectable entity, independent of URLs:
- `type: "order"` with actions `["read", "update", "delete"]`
- `type: "team"` with actions `["invite", "remove_member"]`

### 4.2 Policy Model

```go
type ResourcePolicy struct {
    ID       string
    Type     string
    Version  int
    Actions  map[string]PolicyRule
}

type PolicyRule struct {
    AnyOf []string  // At least one permission required
    AllOf []string  // All permissions required
}
```

#### MongoDB Policy Document
```json
{
  "_id": "order",
  "actions": {
    "read":   { "anyOf": ["orders:read", "orders:manage"] },
    "update": { "allOf": ["orders:write"] },
    "delete": { "anyOf": ["orders:delete"] }
  },
  "version": 1
}
```

### 4.3 Policy Evaluation Process
1. **Lookup** `policy[type].actions[action]`
2. **Fail** if `allOf` requirements not met
3. **Pass** if `anyOf` requirements satisfied
4. **Default deny** for undefined policies

Cache `policy[type]` for 1-5 minutes in gateway layer.

## 5. Gateway / BFF Layer

### 5.1 Core Functions
- **Single entry point** for browser requests
- **Session authentication** and validation
- **Permission evaluation** and enforcement
- **API fan-out** to internal services with proper authorization
- **Response composition** from multiple services
- **Policy enforcement** before upstream calls

### 5.2 Request Flow
1. **Browser** â†’ Gateway (with session cookie)
2. **Gateway** extracts `user_id`, `session_id`
3. **Determine** `(resource.type, action, scope)` from route configuration
4. **Evaluate** permissions using `Has(...)`
5. **If authorized**, call internal API with short-lived token
6. **Include** `res_type`, `action`, `ctx` as signed claims/headers
7. **Microservice** revalidates internally

### 5.3 Route Configuration Example

```yaml
routes:
  - match: "GET /orders/:id"
    resource: { type: "order", action: "read" }
    scope: { from: "path", key: "team_id", fallback: "global" }
    upstream: { service: "orders", path: "/api/orders/:id" }

  - match: "POST /teams/:team_id/orders"
    resource: { type: "order", action: "create" }
    scope: { from: "path", key: "team_id" }
    upstream: { service: "orders", path: "/api/teams/:team_id/orders" }
```

### 5.4 Gateway Implementation Skeleton

```go
type Route struct {
    Method, Pattern string
    ResType, Action string
    ScopeFrom, ScopeKey string
    UpService, UpPath   string
}

func Gateway(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        route, params := matchRoute(r.Method, r.URL.Path)
        scope := extractScope(route.ScopeFrom, route.ScopeKey, params, r)

        userID := userIDFromSession(r)
        if !authz.Can(userID, route.ResType, route.Action, scope) {
            http.Error(w, "forbidden", http.StatusForbidden)
            return
        }

        upstreamURL := fillTemplate(route.UpPath, params)
        token := mintInternalToken(userID, scope)
        forwardRequest(r, route.UpService, upstreamURL, token)
    })
}
```

## 6. Page Composition (HTMX Frontend)

### 6.1 Architecture Characteristics
- **Fragment-based composition**: Each HTML request composed of multiple `blocks`
- **Resource-based authorization**: Each fragment associated with `resource.type` + `action`
- **Pre-flight permission checks**: BFF evaluates permissions before API fan-out
- **Selective rendering**: Only authorized fragments make API calls

### 6.2 Page Declaration

```yaml
pages:
  orders.show:
    route: "GET /teams/:team_id/orders/:id"
    fragments:
      - name: "order_header"
        resource: { type: "order", action: "read" }
        scope: { from: "path", key: "team_id" }
        upstream: { service: "orders", path: "/api/teams/:team_id/orders/:id" }

      - name: "order_actions"
        resource: { type: "order", action: "update" }
        scope: { from: "path", key: "team_id" }
        upstream: { service: "orders", path: "/api/teams/:team_id/orders/:id/actions" }

      - name: "activity_timeline"
        resource: { type: "activity", action: "read" }
        scope: { from: "path", key: "team_id" }
        upstream: { service: "audit", path: "/api/teams/:team_id/orders/:id/events" }
```

### 6.3 Execution Plan
1. **Batch evaluate** permissions for all fragments
2. **Cache results** by session
3. **Execute** only authorized fragments (parallel fan-out)
4. **Render** unauthorized fragments as empty or placeholders
5. **HTMX requests** re-pass through BFF with cached authorization checks

## 7. Token Management Strategy

### 7.1 Token Types
- **Session cookie (browser)**: `HttpOnly`, `Secure`, `SameSite=Strict`
- **Internal token (BFF â†’ microservice)**: Signed, short expiration (1-5 min), cached
- **Reference token (optional)**: Opaque tokens with introspection to AuthZ

### 7.2 Best Practices
- **Short expiration** with aggressive caching
- **Cache by** `session_id + audience` to avoid re-signing
- **Revocation via** session ID denylist or `authz_ver` increment
- **Minimal claims**:
  ```json
  {
    "sub": "user_id",
    "sid": "session_id", 
    "aud": "orders",
    "ctx": {"type": "team", "id": "123"},
    "exp": 1634567890,
    "authz_ver": 42
  }
  ```

## 8. Scope Resolution

### 8.1 Scope Types
- **`global`**: Universal access (system administrators)
- **`team`**: Team-scoped permissions
- **`organization`**: Organization-level access
- **Future**: `project`, `department`, etc.

### 8.2 Scope Extraction Configuration
The gateway defines extraction methods:
- **`from: path`** (e.g., `/teams/:team_id/...`)
- **`from: query`** (e.g., `?team_id=123`)
- **`from: header`** (custom headers)
- **`fallback: global`** (default scope)

## 9. Performance & Caching Strategy

### 9.1 Cache Layers
- **Permissions**: Cache `(userID, permission, scope)` for 30-120 seconds
- **Policies**: Cache by `(type, version)` for 1-5 minutes
- **Internal tokens**: Cache by `session_id + audience` for 1-5 minutes
- **Denylist**: Short TTL, Redis or shared memory

### 9.2 Cache Invalidation
- **Permission changes**: Invalidate user-specific caches
- **Policy updates**: Version-based invalidation
- **Session revocation**: Immediate denylist updates

## 10. System Architecture Summary

| Layer | Responsibility | Communication |
|-------|----------------|---------------|
| **Frontend (HTMX)** | Dynamic HTML UI with fragments | Communicates only with Gateway |
| **Gateway / BFF** | Session management, authorization, API fan-out | Internal HTTP with signed tokens |
| **AuthN Service** | Identity, credentials, session management | RPC/Events to AuthZ |
| **AuthZ Service** | Roles, permissions, policies, scopes | Internal REST APIs |
| **Domain Services** | Business logic and domain rules | Validates tokens and domain rules |

## 11. Core Design Principles

1. **AuthN** knows nothing about permissions, only users and credentials
2. **AuthZ** knows nothing about passwords or sessions
3. **Gateway** decides *if access should be attempted*, microservices decide *if it's appropriate*
4. **No microservice** trusts plain headers - only signed tokens
5. **No direct MongoDB** network access - all through repositories
6. **All readable data** (email, MFA, etc.) encrypted with KMS keys
7. **Policies are versioned** and cached
8. **Zero PII** in logs or traces
9. **GDPR-compliant** deletion and export capabilities
10. **HTMX always** goes through BFF, never direct to services

## 12. Complete Flow Example

### User Request Flow
1. **User** makes `GET /teams/123/orders/42`
2. **Gateway** matches route â†’ `{type:"order", action:"read", scope:{type:"team", id:"123"}}`
3. **Evaluate** `Can(user, "order", "read", team:123)`
4. **Cache hit** â†’ authorization granted
5. **Gateway** creates/reuses internal token (`aud: orders`) and calls `/api/teams/123/orders/42`
6. **Microservice** validates token (signature + `ctx.id` match)
7. **Returns** data to gateway
8. **Gateway** assembles fragments and responds with HTML/HTMX

## 13. Future Extensions

### Planned Enhancements
- **Generic context types** (beyond "team")
- **ABAC (Attribute-Based Access Control)** integration
- **Hybrid RBAC+rules** policies
- **Event bus** (NATS/Kafka) for AuthN/AuthZ synchronization
- **Request-ID propagation** and OpenTelemetry tracing
- **Redis or embedded SQLite** for local PDP cache

## 14. HatMax Integration

### 14.1 Service Definition

This architecture would be generated from a HatMax service definition:

```yaml
version: 0.1
name: "auth-system"
package: "github.com/company/auth-system"

services:
  auth:
    kind: auth
    components:
      - authentication
      - authorization
      - gateway
    
    storage:
      impl: [mongo]
      encryption:
        provider: kms
        fields: [email, mfa_secret]
    
    policies:
      resources:
        - type: order
          actions: [read, write, delete, manage]
        - type: team  
          actions: [invite, remove_member, manage]
      
      scopes:
        - global
        - team
        - organization
```

### 14.2 Generated Components
- **AuthN service** with encrypted storage
- **AuthZ service** with policy engine
- **Gateway/BFF** with route configuration
- **Repository implementations** for MongoDB
- **Token management** utilities
- **HTMX page composition** framework

## Conclusion

This architecture provides a comprehensive, secure, and scalable authentication and authorization solution that integrates seamlessly with the HatMax microservice generation philosophy. It emphasizes security best practices, performance optimization, and maintainable code generation while supporting complex authorization scenarios in modern web applications.

The design maintains clear separation of concerns, implements strong security measures for PII protection, and provides flexible policy management suitable for various organizational structures and access control requirements.