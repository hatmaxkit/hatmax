# Authentication & Authorization Service Architecture

**Status:** Draft | **Updated:** 2025-10-14 | **Version:** 0.1

## Overview

This document defines the architecture for an optional authentication and authorization service that can be generated by HatMax. The system implements a comprehensive AuthN/AuthZ solution using Go, MongoDB, and HTMX, designed for modern microservice architectures with strong security and privacy requirements.

## 1. System Context

The authentication and authorization system consists of two decoupled microservices:

- **Authentication Service (AuthN)**: Manages identity, credentials, and user sessions
- **Authorization Service (AuthZ)**: Controls access permissions, roles, and scopes

Both services operate on MongoDB using **repository-per-aggregate** patterns, fully decoupled from concrete persistence implementations. The frontend uses **HTML + HTMX** (no SPA) with traditional sessions (`HttpOnly` cookies) and internal fan-out to private APIs within the same network.

## 2. Authentication Service

### 2.1 Core Responsibilities

- User registration (`signup`)
- Login/logout with session management
- Administrative user creation
- Event synchronization to AuthZ service (`UserCreated`, `UserDeactivated`)
- Secure credential storage and validation

### 2.2 Data Model

The User aggregate implements comprehensive security measures:

```go
type User struct {
    ID           uuid.UUID
    EmailCT      []byte    // AES-GCM encrypted email
    EmailIV      []byte    // Initialization vector
    EmailTag     []byte    // Authentication tag
    EmailLookup  []byte    // HMAC-SHA256 for searchability
    PasswordHash []byte    // Argon2id hash
    PasswordSalt []byte    // Random salt
    MFASecretCT  []byte    // Encrypted MFA secret (optional)
    Status       string    // active, suspended, deleted
    CreatedAt    time.Time
}
```

### 2.3 Security & Privacy Policy

#### Encryption and Hashing Strategy

| Data Type | Technique | Rationale |
|-----------|-----------|-----------|
| Passwords | Argon2id hash + salt + pepper (KMS) | Non-reversible by design |
| Email addresses | AES-GCM + HMAC lookup | Required for notifications while protecting PII |
| MFA secrets, recovery codes | Encryption or hash (based on read requirements) | Maximum security |
| Application logs | PII-free or masked | Compliance requirements |
| Database backups | Full encryption | Data protection |

#### MongoDB Schema

```json
{
  "_id": "<uuid>",
  "email_ct": "<base64-encrypted-email>",
  "email_iv": "<base64-iv>",
  "email_tag": "<base64-auth-tag>",
  "email_lookup": "<hex-hmac-hash>",
  "pass_hash": "<base64-argon2id-hash>",
  "pass_salt": "<base64-salt>",
  "created_at": "<iso8601-timestamp>",
  "status": "active"
}
```

#### Authentication Flow

1. **Normalize** email input
2. **Calculate** `lookup = HMAC(email, k_lookup)` for database search
3. **Query** by `email_lookup` field
4. **Verify** password against stored hash
5. **Decrypt** email only when necessary (e.g., for notifications)

#### Newsletter and Consent Management

Separate collection `email_subscriptions` handles marketing consent:

```json
{
  "user_id": "<uuid-optional>",
  "email_ct": "<encrypted-email>",
  "email_lookup": "<lookup-hash>",
  "consent": {
    "type": "marketing",
    "scope": "global",
    "timestamp": "<iso8601>",
    "source_ip": "<client-ip>"
  },
  "confirmed_at": "<timestamp>"
}
```

## 3. Authorization Service

### 3.1 Core Responsibilities

- **Role** management and assignment
- **Permission** definition and evaluation
- **Grant** administration (role and permission assignments)
- Support for both global and contextual permissions
- Policy evaluation engine (`Has(user, permission, scope)`)

### 3.2 Domain Aggregates

#### Role Aggregate
```go
type Role struct {
    ID          uuid.UUID
    Name        string
    Permissions []string  // Permission codes
}
```

#### Grant Aggregate
```go
type Grant struct {
    ID         uuid.UUID
    UserID     uuid.UUID
    GrantType  string     // "role" or "permission"
    Value      string     // RoleID or PermissionCode
    Scope      Scope      // Context scope
    ExpiresAt  *time.Time // Optional expiration
}
```

#### Scope Model
```go
type Scope struct {
    Type string // "global", "team", "organization"
    ID   string // Specific ID or empty for global
}
```

### 3.3 Permission Evaluation

#### Core Evaluation Function
```go
func (p *PDP) Has(userID, permission string, scope Scope) (bool, error)
```

#### Evaluation Algorithm
1. **Retrieve** all grants for `user_id`
2. **Filter** expired grants (`expires_at < now`)
3. **Accept** grants with global scope or matching requested scope
4. **Expand** permissions from assigned roles
5. **Return** `true` if requested permission is found

### 3.4 MongoDB Persistence

#### Collections
- `roles` - Role definitions
- `grants` - User permission assignments

#### Indexes
- `grants.user_id` - Primary lookup
- `grants.scope.type` - Scope filtering
- `grants.scope.id` - Context filtering
- `grants.expires_at` (TTL) - Automatic cleanup

### 3.5 Internal Token Management

- **Internal tokens** use `Bearer` format with Ed25519/PASETO signing
- **Minimal claims**: `sub`, `sid`, `aud`, `ctx`, `exp`, `authz_ver`
- **Cache strategy**: By session+audience (1-5 minute TTL)
- **Revocation**: Session ID denylist or `authz_ver` increment

## 4. Authorization Policies & Resources

### 4.1 Resource Abstraction

A **resource** represents a logical protectable entity, independent of URLs:
- `type: "order"` with actions `["read", "update", "delete"]`
- `type: "team"` with actions `["invite", "remove_member"]`

### 4.2 Policy Model

```go
type ResourcePolicy struct {
    ID       string
    Type     string
    Version  int
    Actions  map[string]PolicyRule
}

type PolicyRule struct {
    AnyOf []string  // At least one permission required
    AllOf []string  // All permissions required
}
```

#### MongoDB Policy Document
```json
{
  "_id": "order",
  "actions": {
    "read":   { "anyOf": ["orders:read", "orders:manage"] },
    "update": { "allOf": ["orders:write"] },
    "delete": { "anyOf": ["orders:delete"] }
  },
  "version": 1
}
```

### 4.3 Policy Evaluation Process
1. **Lookup** `policy[type].actions[action]`
2. **Fail** if `allOf` requirements not met
3. **Pass** if `anyOf` requirements satisfied
4. **Default deny** for undefined policies

Cache `policy[type]` for 1-5 minutes in gateway layer.

## 5. Gateway / BFF Layer

### 5.1 Core Functions
- **Single entry point** for browser requests
- **Session authentication** and validation
- **Permission evaluation** and enforcement
- **API fan-out** to internal services with proper authorization
- **Response composition** from multiple services
- **Policy enforcement** before upstream calls

### 5.2 Request Flow
1. **Browser** â†’ Gateway (with session cookie)
2. **Gateway** extracts `user_id`, `session_id`
3. **Determine** `(resource.type, action, scope)` from route configuration
4. **Evaluate** permissions using `Has(...)`
5. **If authorized**, call internal API with short-lived token
6. **Include** `res_type`, `action`, `ctx` as signed claims/headers
7. **Microservice** revalidates internally

### 5.3 Route Configuration Example

```yaml
routes:
  - match: "GET /orders/:id"
    resource: { type: "order", action: "read" }
    scope: { from: "path", key: "team_id", fallback: "global" }
    upstream: { service: "orders", path: "/api/orders/:id" }

  - match: "POST /teams/:team_id/orders"
    resource: { type: "order", action: "create" }
    scope: { from: "path", key: "team_id" }
    upstream: { service: "orders", path: "/api/teams/:team_id/orders" }
```

### 5.4 Gateway Implementation Skeleton

```go
type Route struct {
    Method, Pattern string
    ResType, Action string
    ScopeFrom, ScopeKey string
    UpService, UpPath   string
}

func Gateway(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        route, params := matchRoute(r.Method, r.URL.Path)
        scope := extractScope(route.ScopeFrom, route.ScopeKey, params, r)

        userID := userIDFromSession(r)
        if !authz.Can(userID, route.ResType, route.Action, scope) {
            http.Error(w, "forbidden", http.StatusForbidden)
            return
        }

        upstreamURL := fillTemplate(route.UpPath, params)
        token := mintInternalToken(userID, scope)
        forwardRequest(r, route.UpService, upstreamURL, token)
    })
}
```

## 6. Page Composition (HTMX Frontend)

### 6.1 Architecture Characteristics
- **Fragment-based composition**: Each HTML request composed of multiple `blocks`
- **Resource-based authorization**: Each fragment associated with `resource.type` + `action`
- **Pre-flight permission checks**: BFF evaluates permissions before API fan-out
- **Selective rendering**: Only authorized fragments make API calls

### 6.2 Page Declaration

```yaml
pages:
  orders.show:
    route: "GET /teams/:team_id/orders/:id"
    fragments:
      - name: "order_header"
        resource: { type: "order", action: "read" }
        scope: { from: "path", key: "team_id" }
        upstream: { service: "orders", path: "/api/teams/:team_id/orders/:id" }

      - name: "order_actions"
        resource: { type: "order", action: "update" }
        scope: { from: "path", key: "team_id" }
        upstream: { service: "orders", path: "/api/teams/:team_id/orders/:id/actions" }

      - name: "activity_timeline"
        resource: { type: "activity", action: "read" }
        scope: { from: "path", key: "team_id" }
        upstream: { service: "audit", path: "/api/teams/:team_id/orders/:id/events" }
```

### 6.3 Execution Plan
1. **Batch evaluate** permissions for all fragments
2. **Cache results** by session
3. **Execute** only authorized fragments (parallel fan-out)
4. **Render** unauthorized fragments as empty or placeholders
5. **HTMX requests** re-pass through BFF with cached authorization checks

## 7. Token Management Strategy

### 7.1 Token Types
- **Session cookie (browser)**: `HttpOnly`, `Secure`, `SameSite=Strict`
- **Internal token (BFF â†’ microservice)**: Signed, short expiration (1-5 min), cached
- **Reference token (optional)**: Opaque tokens with introspection to AuthZ

### 7.2 Best Practices
- **Short expiration** with aggressive caching
- **Cache by** `session_id + audience` to avoid re-signing
- **Revocation via** session ID denylist or `authz_ver` increment
- **Minimal claims**:
  ```json
  {
    "sub": "user_id",
    "sid": "session_id", 
    "aud": "orders",
    "ctx": {"type": "team", "id": "123"},
    "exp": 1634567890,
    "authz_ver": 42
  }
  ```

## 8. Scope Resolution

### 8.1 Scope Types
- **`global`**: Universal access (system administrators)
- **`team`**: Team-scoped permissions
- **`organization`**: Organization-level access
- **Future**: `project`, `department`, etc.

### 8.2 Scope Extraction Configuration
The gateway defines extraction methods:
- **`from: path`** (e.g., `/teams/:team_id/...`)
- **`from: query`** (e.g., `?team_id=123`)
- **`from: header`** (custom headers)
- **`fallback: global`** (default scope)

## 9. Performance & Caching Strategy

### 9.1 Cache Layers
- **Permissions**: Cache `(userID, permission, scope)` for 30-120 seconds
- **Policies**: Cache by `(type, version)` for 1-5 minutes
- **Internal tokens**: Cache by `session_id + audience` for 1-5 minutes
- **Denylist**: Short TTL, Redis or shared memory

### 9.2 Cache Invalidation
- **Permission changes**: Invalidate user-specific caches
- **Policy updates**: Version-based invalidation
- **Session revocation**: Immediate denylist updates

## 10. System Architecture Summary

| Layer | Responsibility | Communication |
|-------|----------------|---------------|
| **Frontend (HTMX)** | Dynamic HTML UI with fragments | Communicates only with Gateway |
| **Gateway / BFF** | Session management, authorization, API fan-out | Internal HTTP with signed tokens |
| **AuthN Service** | Identity, credentials, session management | RPC/Events to AuthZ |
| **AuthZ Service** | Roles, permissions, policies, scopes | Internal REST APIs |
| **Domain Services** | Business logic and domain rules | Validates tokens and domain rules |

## 11. Core Design Principles

1. **AuthN** knows nothing about permissions, only users and credentials
2. **AuthZ** knows nothing about passwords or sessions
3. **Gateway** decides *if access should be attempted*, microservices decide *if it's appropriate*
4. **No microservice** trusts plain headers - only signed tokens
5. **No direct MongoDB** network access - all through repositories
6. **All readable data** (email, MFA, etc.) encrypted with KMS keys
7. **Policies are versioned** and cached
8. **Zero PII** in logs or traces
9. **GDPR-compliant** deletion and export capabilities
10. **HTMX always** goes through BFF, never direct to services

## 12. Complete Flow Example

### User Request Flow
1. **User** makes `GET /teams/123/orders/42`
2. **Gateway** matches route â†’ `{type:"order", action:"read", scope:{type:"team", id:"123"}}`
3. **Evaluate** `Can(user, "order", "read", team:123)`
4. **Cache hit** â†’ authorization granted
5. **Gateway** creates/reuses internal token (`aud: orders`) and calls `/api/teams/123/orders/42`
6. **Microservice** validates token (signature + `ctx.id` match)
7. **Returns** data to gateway
8. **Gateway** assembles fragments and responds with HTML/HTMX

## 13. Practical Authorization Scenarios

### 13.1 Business Application: Todo List Service

Consider an enterprise todo list application accessed through an HTMX web interface. The web layer translates user interactions into internal API calls to the todo service, which requires proper authorization through AuthZ.

#### 13.2 Role Definitions

Roles define what actions users can perform based on their organizational responsibilities:

```bash
# Functional Roles
- "admin"              # Full system access
- "manager"            # Team management capabilities
- "employee"           # Individual contributor access
- "viewer"             # Read-only access

# Department-Specific Roles  
- "hr_manager"         # Human Resources management
- "finance_viewer"     # Financial data access
- "marketing_employee" # Marketing team member
```

#### 13.3 Permission Structure

Permissions represent specific actions available in the system:

```bash
# Basic CRUD Operations
- "read:todos"         # View todo lists
- "create:todos"       # Create new todos
- "update:todos"       # Edit existing todos  
- "delete:todos"       # Remove todos

# Administrative Functions
- "manage:users"       # User management
- "view:reports"       # System analytics
- "export:data"        # Data export capabilities

# Advanced Operations
- "assign:todos"       # Assign todos to others
- "archive:projects"   # Archive completed projects
```

#### 13.4 Resource Scoping

Scopes define the data boundaries for permission application:

```bash
# Ownership-Based Scopes
- "/todos/own"          # User's personal todos only
- "/todos/team"         # Team-shared todos  
- "/todos/department"   # Department-wide todos
- "/todos/all"          # Organization-wide access

# Content-Based Scopes
- "/todos/personal"     # Personal task lists
- "/todos/project/*"    # Project-specific todos
- "/reports/analytics"  # System reporting data
```

### 13.5 Real-World User Examples

#### Example A: Marketing Employee (John)
```bash
# Role Assignment
ROLE: "marketing_employee"
PERMISSIONS: ["read:todos", "create:todos", "update:todos"]

# Resource Grants
GRANT: user_john â†’ role "marketing_employee" â†’ scope "/todos/own"
GRANT: user_john â†’ role "marketing_employee" â†’ scope "/todos/team"
```

**Result**: John can view, create, and edit his personal todos plus his marketing team's shared todos, but cannot delete or access other departments.

#### Example B: Finance Manager (Sarah)
```bash
# Role Assignment  
ROLE: "finance_manager"
PERMISSIONS: ["read:todos", "create:todos", "update:todos", "delete:todos", "view:reports"]

# Resource Grants
GRANT: user_sarah â†’ role "finance_manager" â†’ scope "/todos/department"
GRANT: user_sarah â†’ role "finance_manager" â†’ scope "/reports/analytics"
```

**Result**: Sarah has full CRUD access to all finance department todos and can view system reports.

#### Example C: System Administrator (Mike)
```bash
# Role Assignment
ROLE: "admin"
PERMISSIONS: ["*"] # Wildcard for all permissions

# Global Access Grants
GRANT: user_mike â†’ role "admin" â†’ scope "/todos/all"
GRANT: user_mike â†’ role "admin" â†’ scope "/reports/all"
```

**Result**: Mike has unrestricted access to all system functions and data.

### 13.6 Authorization Flow Example

When John attempts to view a team todo item:

1. **Web Interface**: User clicks "View Todo #456 - Marketing Campaign"
2. **HTMX Request**: `GET /teams/marketing/todos/456`
3. **Gateway Translation**: Maps to internal API `GET /api/todos/456`
4. **Todo Service**: Queries AuthZ before processing:
   ```json
   {
     "user_id": "john_uuid_here",
     "permission": "read:todos",
     "scope": {"type": "resource", "id": "/todos/team"}
   }
   ```
5. **AuthZ Response**: `{"allowed": true}` âœ…
6. **Todo Service**: Returns todo data
7. **Web Interface**: Renders todo details via HTMX

### 13.7 Setup Automation Scripts

Practical scripts for configuring authorization in development/staging:

#### Role Creation Script
```bash
#!/bin/bash
# setup-todo-roles.sh - Create all necessary roles

AUTHZ_URL="http://localhost:8083"

# Create basic roles
curl -X POST $AUTHZ_URL/authz/roles -H "Content-Type: application/json" -d '{
  "name": "employee",
  "description": "Standard employee access", 
  "permissions": ["read:todos", "create:todos", "update:todos"]
}'

curl -X POST $AUTHZ_URL/authz/roles -H "Content-Type: application/json" -d '{
  "name": "manager",
  "description": "Team management access",
  "permissions": ["read:todos", "create:todos", "update:todos", "delete:todos", "assign:todos"]
}'

curl -X POST $AUTHZ_URL/authz/roles -H "Content-Type: application/json" -d '{
  "name": "admin", 
  "description": "Full system access",
  "permissions": ["*"]
}'
```

#### User Permission Assignment
```bash
#!/bin/bash
# assign-user-permissions.sh - Grant roles to specific users

USER_EMAIL="john@company.com"
USER_ROLE="employee"
RESOURCE_SCOPE="/todos/team"

# Get user ID from AuthN service
USER_ID=$(curl -s "$AUTHN_URL/authn/users?email=$USER_EMAIL" | jq -r '.data.id')

# Grant role to user
curl -X POST $AUTHZ_URL/authz/grants -H "Content-Type: application/json" -d "{
  \"user_id\": \"$USER_ID\",
  \"role_name\": \"$USER_ROLE\", 
  \"resource\": \"$RESOURCE_SCOPE\"
}"
```

### 13.8 Testing Authorization Scenarios

Comprehensive testing approach for various access patterns:

```bash
#!/bin/bash
# test-todo-permissions.sh - Verify authorization works correctly

# Test employee access to own todos
test_permission "$EMPLOYEE_USER" "read:todos" "/todos/own" true

# Test employee cannot delete todos
test_permission "$EMPLOYEE_USER" "delete:todos" "/todos/own" false

# Test manager can delete team todos  
test_permission "$MANAGER_USER" "delete:todos" "/todos/team" true

# Test cross-department access denied
test_permission "$MARKETING_USER" "read:todos" "/todos/finance" false
```

### 13.9 Integration Considerations

#### Web Layer Authorization Checks
The HTMX web interface should validate permissions before rendering UI elements:

```html
<!-- Only show delete button for users with delete:todos permission -->
<div hx-get="/api/permissions/check?permission=delete:todos&resource=/todos/team" 
     hx-trigger="load"
     hx-target="#delete-button-container">
</div>
```

#### Service-to-Service Authorization
Each microservice should validate tokens and re-check permissions:

```go
// In todo service handler
func (h *TodoHandler) DeleteTodo(w http.ResponseWriter, r *http.Request) {
    userID := extractUserFromToken(r)
    todoID := chi.URLParam(r, "id")
    
    // Re-verify permission before processing
    allowed, err := h.authz.CheckPermission(r.Context(), userID, "delete:todos", "/todos/team")
    if err != nil || !allowed {
        http.Error(w, "Forbidden", http.StatusForbidden)
        return
    }
    
    // Process deletion
}
```

## 14. Future Extensions

### Planned Enhancements
- **Generic context types** (beyond "team")
- **ABAC (Attribute-Based Access Control)** integration
- **Hybrid RBAC+rules** policies
- **Event bus** (NATS/Kafka) for AuthN/AuthZ synchronization
- **Request-ID propagation** and OpenTelemetry tracing
- **Redis or embedded SQLite** for local PDP cache

## 15. HatMax Integration

### 15.1 Service Definition

This architecture would be generated from a HatMax service definition:

```yaml
version: 0.1
name: "auth-system"
package: "github.com/company/auth-system"

services:
  auth:
    kind: auth
    components:
      - authentication
      - authorization
      - gateway
    
    storage:
      impl: [mongo]
      encryption:
        provider: kms
        fields: [email, mfa_secret]
    
    policies:
      resources:
        - type: order
          actions: [read, write, delete, manage]
        - type: team  
          actions: [invite, remove_member, manage]
      
      scopes:
        - global
        - team
        - organization
```

### 14.2 Generated Components
- **AuthN service** with encrypted storage
- **AuthZ service** with policy engine
- **Gateway/BFF** with route configuration
- **Repository implementations** for MongoDB
- **Token management** utilities
- **HTMX page composition** framework

## Conclusion

This architecture provides a comprehensive, secure, and scalable authentication and authorization solution that integrates seamlessly with the HatMax microservice generation philosophy. It emphasizes security best practices, performance optimization, and maintainable code generation while supporting complex authorization scenarios in modern web applications.

The design maintains clear separation of concerns, implements strong security measures for PII protection, and provides flexible policy management suitable for various organizational structures and access control requirements.